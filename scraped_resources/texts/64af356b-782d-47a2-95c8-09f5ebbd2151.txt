Start Here Learn Python Python Tutorials Video Courses Interactive Quizzes Learning Paths Browse Topics Unlock All Content Store RP Membership Python Basics Book Python Tricks Book The Real Python Course Managing Python Dependencies Sublime Text Python Setup Pythonic Wallpapers Pack Python Mugs TShirts and More Pythonista Cafe Community Browse All » More Python Newsletter Python Job Board The Team Write for Us Join Sign In Python’s Requests Library Guide by Alex Ronquillo Jan intermediate webdev Tweet Share Email Table of Contents Getting Started With requests The GET Request The Response Status Codes Content Headers Query String Parameters Request Headers Other HTTP Methods The Message Body Inspecting Your Request Authentication SSL Certificate Verification Performance Timeouts The Session Object Max Retries Conclusion Watch Now This tutorial has a related video course created by the Real Python team Watch it together with the written tutorial to deepen your understanding Making HTTP Requests With Python The requests library is the de facto standard for making HTTP requests in Python It abstracts the complexities of making requests behind a beautiful simple API so that you can focus on interacting with services and consuming data in your application Throughout this article youll see some of the most useful features that requests has to offer as well as how to customize and optimize those features for different situations you may come across Youll also learn how to use requests in an efficient way as well as how to prevent requests to external services from slowing down your application In this tutorial youll learn how to Make requests using the most common HTTP methods Customize your requests headers and data using the query string and message body Inspect data from your requests and responses Make authenticated requests Configure your requests to help prevent your application from backing up or slowing down Though Ive tried to include as much information as you need to understand the features and examples included in this article I do assume a very basic general knowledge of HTTP That said you still may be able to follow along fine anyway Now that that is out of the way lets dive in and see how you can use requests in your application Remove ads Getting Started With requests Lets begin by installing the requests library To do so run the following command pip install requests If you prefer to use Pipenv for managing Python packages you can run the following pipenv install requests Once requests is installed you can use it in your application Importing requests looks like this import requests Now that youre all set up its time to begin your journey through requests Your first goal will be learning how to make a GET request The GET Request HTTP methods such as GET and POST determine which action youre trying to perform when making an HTTP request Besides GET and POST there are several other common methods that youll use later in this tutorial One of the most common HTTP methods is GET The GET method indicates that youre trying to get or retrieve data from a specified resource To make a GET request invoke requestsget To test this out you can make a GET request to GitHubs Root REST API by calling get with the following URL requestsget Response Congratulations Youve made your first request Lets dive a little deeper into the response of that request The Response A Response is a powerful object for inspecting the results of the request Lets make that same request again but this time store the return value in a variable so that you can get a closer look at its attributes and behaviors response requestsget In this example youve captured the return value of get which is an instance of Response and stored it in a variable called response You can now use response to see a lot of information about the results of your GET request Status Codes The first bit of information that you can gather from Response is the status code A status code informs you of the status of the request For example a OK status means that your request was successful whereas a NOT FOUND status means that the resource you were looking for was not found There are many other possible status codes as well to give you specific insights into what happened with your request By accessing statuscode you can see the status code that the server returned responsestatuscode statuscode returned a which means your request was successful and the server responded with the data you were requesting Sometimes you might want to use this information to make decisions in your code if responsestatuscode printSuccess elif responsestatuscode printNot Found With this logic if the server returns a status code your program will print Success If the result is a your program will print Not Found requests goes one step further in simplifying this process for you If you use a Response instance in a conditional expression it will evaluate to True if the status code was between and and False otherwise Therefore you can simplify the last example by rewriting the if statement if response printSuccess else printAn error has occurred Technical Detail This Truth Value Test is made possible because bool is an overloaded method on Response This means that the default behavior of Response has been redefined to take the status code into account when determining the truth value of the object Keep in mind that this method is not verifying that the status code is equal to The reason for this is that other status codes within the to range such as NO CONTENT and NOT MODIFIED are also considered successful in the sense that they provide some workable response For example the tells you that the response was successful but theres no content to return in the message body So make sure you use this convenient shorthand only if you want to know if the request was generally successful and then if necessary handle the response appropriately based on the status code Lets say you dont want to check the responses status code in an if statement Instead you want to raise an exception if the request was unsuccessful You can do this using raiseforstatus import requests from requestsexceptions import HTTPError for url in try response requestsgeturl If the response was successful no Exception will be raised responseraiseforstatus except HTTPError as httperr printfHTTP error occurred httperr Python except Exception as err printfOther error occurred err Python else printSuccess If you invoke raiseforstatus an HTTPError will be raised for certain status codes If the status code indicates a successful request the program will proceed without that exception being raised Further Reading If youre not familiar with Python s fstrings I encourage you to take advantage of them as they are a great way to simplify your formatted strings Now you know a lot about how to deal with the status code of the response you got back from the server However when you make a GET request you rarely only care about the status code of the response Usually you want to see more Next youll see how to view the actual data that the server sent back in the body of the response Content The response of a GET request often has some valuable information known as a payload in the message body Using the attributes and methods of Response you can view the payload in a variety of different formats To see the responses content in bytes you use content response requestsget responsecontent bcurrentuserurl While content gives you access to the raw bytes of the response payload you will often want to convert them into a string using a character encoding such as UTF response will do that for you when you access text responsetext currentuserurl Because the decoding of bytes to a str requires an encoding scheme requests will try to guess the encoding based on the responses headers if you do not specify one You can provide an explicit encoding by setting encoding before accessing text responseencoding utf Optional requests infers this internally responsetext currentuserurl If you take a look at the response youll see that it is actually serialized JSON content To get a dictionary you could take the str you retrieved from text and deserialize it using jsonloads However a simpler way to accomplish this task is to use json responsejson currentuserurl currentuserauthorizationshtmlurl authorizationsurl codesearchurl commitsearchurl emailsurl emojisurl eventsurl feedsurl followersurl followingurl gistsurl huburl issuesearchurl issuesurl keysurl notificationsurl organizationrepositoriesurl organizationurl publicgistsurl ratelimiturl repositoryurl repositorysearchurl currentuserrepositoriesurl starredurl starredgistsurl teamurl userurl userorganizationsurl userrepositoriesurl usersearchurl The type of the return value of json is a dictionary so you can access values in the object by key You can do a lot with status codes and message bodies But if you need more information like metadata about the response itself youll need to look at the responses headers Headers The response headers can give you useful information such as the content type of the response payload and a time limit on how long to cache the response To view these headers access headers responseheaders Server GitHubcom Date Mon Dec GMT ContentType applicationjson charsetutf TransferEncoding chunked Status OK XRateLimitLimit XRateLimitRemaining XRateLimitReset CacheControl public maxage smaxage Vary Accept ETag W XGitHubMediaType github formatjson AccessControlExposeHeaders ETag Link Location RetryAfter XGitHubOTP XRateLimitLimit XRateLimitRemaining XRateLimitReset XOAuthScopes XAcceptedOAuthScopes XPollInterval XGitHubMediaType AccessControlAllowOrigin StrictTransportSecurity maxage includeSubdomains preload XFrameOptions deny XContentTypeOptions nosniff XXSSProtection modeblock ReferrerPolicy originwhencrossorigin strictoriginwhencrossorigin ContentSecurityPolicy defaultsrc none ContentEncoding gzip XGitHubRequestId headers returns a dictionarylike object allowing you to access header values by key For example to see the content type of the response payload you can access ContentType responseheadersContentType applicationjson charsetutf There is something special about this dictionarylike headers object though The HTTP spec defines headers to be caseinsensitive which means we are able to access these headers without worrying about their capitalization responseheaderscontenttype applicationjson charsetutf Whether you use the key contenttype or ContentType youll get the same value Now youve learned the basics about Response Youve seen its most useful attributes and methods in action Lets take a step back and see how your responses change when you customize your GET requests Remove ads Query String Parameters One common way to customize a GET request is to pass values through query string parameters in the URL To do this using get you pass data to params For example you can use GitHubs Search API to look for the requests library import requests Search GitHubs repositories for requests response requestsget paramsq requestslanguagepython Inspect some attributes of the requests repository jsonresponse responsejson repository jsonresponseitems printfRepository name repositoryname Python printfRepository description repositorydescription Python By passing the dictionary q requestslanguagepython to the params parameter of get you are able to modify the results that come back from the Search API You can pass params to get in the form of a dictionary as you have just done or as a list of tuples requestsget paramsq requestslanguagepython Response You can even pass the values as bytes requestsget paramsbqrequestslanguagepython Response Query strings are useful for parameterizing GET requests You can also customize your requests by adding or modifying the headers you send Request Headers To customize headers you pass a dictionary of HTTP headers to get using the headers parameter For example you can change your previous search request to highlight matching search terms in the results by specifying the textmatch media type in the Accept header import requests response requestsget paramsq requestslanguagepython headersAccept applicationvndgithub textmatchjson View the new textmatches array which provides information about your search term within the results jsonresponse responsejson repository jsonresponseitems printfText matches repositorytextmatches The Accept header tells the server what content types your application can handle In this case since youre expecting the matching search terms to be highlighted youre using the header value applicationvndgithub text matchjson which is a proprietary GitHub Accept header where the content is a special JSON format Before you learn more ways to customize requests lets broaden the horizon by exploring other HTTP methods Other HTTP Methods Aside from GET other popular HTTP methods include POST PUT DELETE HEAD PATCH and OPTIONS requests provides a method with a similar signature to get for each of these HTTP methods requestspost datakeyvalue requestsput datakeyvalue requestsdelete requestshead requestspatch datakeyvalue requestsoptions Each function call makes a request to the httpbin service using the corresponding HTTP method For each method you can inspect their responses in the same way you did before response requestshead responseheadersContentType applicationjson response requestsdelete jsonresponse responsejson jsonresponseargs Headers response bodies status codes and more are returned in the Response for each method Next youll take a closer look at the POST PUT and PATCH methods and learn how they differ from the other request types The Message Body According to the HTTP specification POST PUT and the less common PATCH requests pass their data through the message body rather than through parameters in the query string Using requests youll pass the payload to the corresponding functions data parameter data takes a dictionary a list of tuples bytes or a filelike object Youll want to adapt the data you send in the body of your request to the specific needs of the service youre interacting with For example if your requests content type is applicationxwwwform urlencoded you can send the form data as a dictionary requestspost datakeyvalue Response You can also send that same data as a list of tuples requestspost datakey value Response If however you need to send JSON data you can use the json parameter When you pass JSON data via json requests will serialize your data and add the correct ContentType header for you httpbinorg is a great resource created by the author of requests Kenneth Reitz Its a service that accepts test requests and responds with data about the requests For instance you can use it to inspect a basic POST request response requestspost jsonkeyvalue jsonresponse responsejson jsonresponsedata key value jsonresponseheadersContentType applicationjson You can see from the response that the server received your request data and headers as you sent them requests also provides this information to you in the form of a PreparedRequest Inspecting Your Request When you make a request the requests library prepares the request before actually sending it to the destination server Request preparation includes things like validating headers and serializing JSON content You can view the PreparedRequest by accessing request response requestspost jsonkeyvalue responserequestheadersContentType applicationjson responserequesturl responserequestbody bkey value Inspecting the PreparedRequest gives you access to all kinds of information about the request being made such as payload URL headers authentication and more So far youve made a lot of different kinds of requests but theyve all had one thing in common theyre unauthenticated requests to public APIs Many services you may come across will want you to authenticate in some way Authentication Authentication helps a service understand who you are Typically you provide your credentials to a server by passing data through the Authorization header or a custom header defined by the service All the request functions youve seen to this point provide a parameter called auth which allows you to pass your credentials One example of an API that requires authentication is GitHubs Authenticated User API This endpoint provides information about the authenticated users profile To make a request to the Authenticated User API you can pass your GitHub username and password in a tuple to get from getpass import getpass requestsget authusername getpass Response The request succeeded if the credentials you passed in the tuple to auth are valid If you try to make this request with no credentials youll see that the status code is Unauthorized requestsget Response When you pass your username and password in a tuple to the auth parameter requests is applying the credentials using HTTPs Basic access authentication scheme under the hood Therefore you could make the same request by passing explicit Basic authentication credentials using HTTPBasicAuth from requestsauth import HTTPBasicAuth from getpass import getpass requestsget authHTTPBasicAuthusername getpass Response Though you dont need to be explicit for Basic authentication you may want to authenticate using another method requests provides other methods of authentication out of the box such as HTTPDigestAuth and HTTPProxyAuth You can even supply your own authentication mechanism To do so you must first create a subclass of AuthBase Then you implement call import requests from requestsauth import AuthBase class TokenAuthAuthBase Implements a custom authentication scheme def initself token selftoken token def callself r Attach an API token to a custom auth header rheadersXTokenAuth fselftoken Python return r requestsget authTokenAuth token Here your custom TokenAuth mechanism receives a token then includes that token in the XTokenAuth header of your request Bad authentication mechanisms can lead to security vulnerabilities so unless a service requires a custom authentication mechanism for some reason youll always want to use a triedandtrue auth scheme like Basic or OAuth While youre thinking about security lets consider dealing with SSL Certificates using requests SSL Certificate Verification Any time the data you are trying to send or receive is sensitive security is important The way that you communicate with secure sites over HTTP is by establishing an encrypted connection using SSL which means that verifying the target servers SSL Certificate is critical The good news is that requests does this for you by default However there are some cases where you might want to change this behavior If you want to disable SSL Certificate verification you pass False to the verify parameter of the request function requestsget verifyFalse InsecureRequestWarning Unverified HTTPS request is being made Adding certificate verification is strongly advised See https InsecureRequestWarning Response requests even warns you when youre making an insecure request to help you keep your data safe Note requests uses a package called certifi to provide Certificate Authorities This lets requests know which authorities it can trust Therefore you should update certifi frequently to keep your connections as secure as possible Performance When using requests especially in a production application environment its important to consider performance implications Features like timeout control sessions and retry limits can help you keep your application running smoothly Timeouts When you make an inline request to an external service your system will need to wait upon the response before moving on If your application waits too long for that response requests to your service could back up your user experience could suffer or your background jobs could hang By default requests will wait indefinitely on the response so you should almost always specify a timeout duration to prevent these things from happening To set the requests timeout use the timeout parameter timeout can be an integer or float representing the number of seconds to wait on a response before timing out requestsget timeout Response requestsget timeout Response In the first request the request will timeout after second In the second request the request will timeout after seconds You can also pass a tuple to timeout with the first element being a connect timeout the time it allows for the client to establish a connection to the server and the second being a read timeout the time it will wait on a response once your client has established a connection requestsget timeout Response If the request establishes a connection within seconds and receives data within seconds of the connection being established then the response will be returned as it was before If the request times out then the function will raise a Timeout exception import requests from requestsexceptions import Timeout try response requestsget timeout except Timeout printThe request timed out else printThe request did not time out Your program can catch the Timeout exception and respond accordingly The Session Object Until now youve been dealing with high level requests APIs such as get and post These functions are abstractions of whats going on when you make your requests They hide implementation details such as how connections are managed so that you dont have to worry about them Underneath those abstractions is a class called Session If you need to finetune your control over how requests are being made or improve the performance of your requests you may need to use a Session instance directly Sessions are used to persist parameters across requests For example if you want to use the same authentication across multiple requests you could use a session import requests from getpass import getpass By using a context manager you can ensure the resources used by the session will be released after use with requestsSession as session sessionauth username getpass Instead of requestsget youll use sessionget response sessionget You can inspect the response just like you did before printresponseheaders printresponsejson Each time you make a request with session once it has been initialized with authentication credentials the credentials will be persisted The primary performance optimization of sessions comes in the form of persistent connections When your app makes a connection to a server using a Session it keeps that connection around in a connection pool When your app wants to connect to the same server again it will reuse a connection from the pool rather than establishing a new one Max Retries When a request fails you may want your application to retry the same request However requests will not do this for you by default To apply this functionality you need to implement a custom Transport Adapter Transport Adapters let you define a set of configurations per service youre interacting with For example lets say you want all requests to to retry three times before finally raising a ConnectionError You would build a Transport Adapter set its maxretries parameter and mount it to an existing Session import requests from requestsadapters import HTTPAdapter from requestsexceptions import ConnectionError githubadapter HTTPAdaptermaxretries session requestsSession Use githubadapter for all requests to endpoints that start with this URL sessionmount githubadapter try sessionget except ConnectionError as ce printce When you mount the HTTPAdapter githubadapter to session session will adhere to its configuration for each request to Timeouts Transport Adapters and sessions are for keeping your code efficient and your application resilient Remove ads Conclusion Youve come a long way in learning about Pythons powerful requests library Youre now able to Make requests using a variety of different HTTP methods such as GET POST and PUT Customize your requests by modifying headers authentication query strings and message bodies Inspect the data you send to the server and the data the server sends back to you Work with SSL Certificate verification Use requests effectively using maxretries timeout Sessions and Transport Adapters Because you learned how to use requests youre equipped to explore the wide world of web services and build awesome applications using the fascinating data they provide Watch Now This tutorial has a related video course created by the Real Python team Watch it together with the written tutorial to deepen your understanding Making HTTP Requests With Python 🐍 Python Tricks 💌 Get a short sweet Python Trick delivered to your inbox every couple of days No spam ever Unsubscribe any time Curated by the Real Python team Send Me Python Tricks » About Alex Ronquillo Alex Ronquillo is a Software Engineer at YouVersion He’s an avid Pythonista who is also passionate about writing and game development » More about Alex Each tutorial at Real Python is created by a team of developers so that it meets our high quality standards The team members who worked on this tutorial are Aldren Brad Joanna What Do You Think Tweet Share Email Real Python Comment Policy The most useful comments are those written with the goal of learning from or helping out other readers—after reading the whole article and all the earlier comments Complaints and insults generally won’t make the cut here Keep Learning Related Tutorial Categories intermediate webdev Recommended Video Course Making HTTP Requests With Python Master RealWorld Python Skills With Unlimited Access to Real Python Already a member Log In Join us and get access to hundreds of tutorials handson video courses and a community of expert Pythonistas See Membership Options » Close — FREE Email Series — 🐍 Python Tricks 💌 Get Python Tricks » 🔒 No spam Unsubscribe any time All Tutorial Topics advanced api basics bestpractices community databases datascience devops django docker flask frontend intermediate machinelearning python testing tools webdev webscraping Table of Contents Getting Started With requests The GET Request The Response Status Codes Content Headers Query String Parameters Request Headers Other HTTP Methods The Message Body Inspecting Your Request Authentication SSL Certificate Verification Performance Timeouts The Session Object Max Retries Conclusion Tweet Share Email Recommended Video Course Making HTTP Requests With Python © – Real Python ⋅ Newsletter ⋅ YouTube ⋅ Twitter ⋅ Facebook ⋅ Instagram Python Tutorials ⋅ Search ⋅ Privacy Policy ⋅ Advertise ⋅ Contact ❤️ Happy Pythoning